"""
Dropship Automator — Clean Full Hybrid
Author: Kristian Õmmik (merged & cleaned)
Purpose: Production-ready hybrid combining a clear skeleton with the full-feature feature set.
Notes:
 - This is a runnable, self-contained skeleton that simulates external API calls by default
 - Secrets (API keys, tokens) are stored encrypted in `config.enc`
 - Replace simulated endpoints and payloads with real API calls and OAuth flows before using in production
"""

import os
import json
import time
import logging
import threading
import requests
import sqlite3
from datetime import datetime
from functools import wraps
from cryptography.fernet import Fernet
import tkinter as tk
from tkinter import ttk, filedialog, messagebox, scrolledtext, simpledialog
import csv
import re
import difflib
import schedule
from io import BytesIO
from PIL import Image, ImageDraw, ImageFont
import matplotlib.pyplot as plt

# -------------------------- Paths & Logging -------------------------------
APP_DIR = os.path.dirname(__file__) or '.'
KEY_FILE = os.path.join(APP_DIR, 'secret.key')
CONFIG_FILE = os.path.join(APP_DIR, 'config.enc')
DB_FILE = os.path.join(APP_DIR, 'dropship.db')
LOG_FILE = os.path.join(APP_DIR, 'dropship.log')

logging.basicConfig(filename=LOG_FILE, level=logging.INFO, format='%(asctime)s %(levelname)s %(message)s')
logger = logging.getLogger('dropship')

# -------------------------- Defaults & Mappings --------------------------
DEFAULTS = {
    'ali_app_key': '',
    'ali_app_secret': '',
    'ebay_client_id': '',
    'ebay_client_secret': '',
    'ebay_token': '',
    'marketplace_id': 'EBAY-AU',
    'markup_percent': 30.0,
    'sync_interval_hours': 6,
    'max_retries': 3,
    'retry_backoff_seconds': 2,
    'use_sandbox': True,
}

ALI_TO_EBAY = {
    'Phones & Telecommunications': '15032',
    'Computer & Office': '58058',
    'Consumer Electronics': '293',
    "Women's Clothing": '11450',
    'Home & Garden': '11700',
}

# -------------------------- Encryption helpers --------------------------

def load_or_create_key():
    if not os.path.exists(KEY_FILE):
        key = Fernet.generate_key()
        with open(KEY_FILE, 'wb') as f:
            f.write(key)
    with open(KEY_FILE, 'rb') as f:
        return f.read()

FERNET_KEY = load_or_create_key()
FERNET = Fernet(FERNET_KEY)


def encrypt_config(obj: dict):
    raw = json.dumps(obj).encode('utf-8')
    return FERNET.encrypt(raw)


def decrypt_config(blob: bytes):
    data = FERNET.decrypt(blob)
    return json.loads(data.decode('utf-8'))


def save_config(cfg: dict):
    with open(CONFIG_FILE, 'wb') as f:
        f.write(encrypt_config(cfg))
    logger.info('Config saved (encrypted)')


def load_config():
    if not os.path.exists(CONFIG_FILE):
        save_config(DEFAULTS.copy())
        return DEFAULTS.copy()
    try:
        with open(CONFIG_FILE, 'rb') as f:
            blob = f.read()
        cfg = decrypt_config(blob)
        merged = DEFAULTS.copy()
        merged.update(cfg)
        return merged
    except Exception as e:
        logger.exception('Failed to load config: %s', e)
        save_config(DEFAULTS.copy())
        return DEFAULTS.copy()

# -------------------------- Database -------------------------------------

def init_db():
    conn = sqlite3.connect(DB_FILE)
    c = conn.cursor()
    c.execute('''
        CREATE TABLE IF NOT EXISTS products (
            id INTEGER PRIMARY KEY AUTOINCREMENT,
            ali_product_id TEXT UNIQUE,
            title TEXT,
            ebay_item_id TEXT,
            price REAL,
            qty INTEGER,
            last_sync TIMESTAMP,
            raw TEXT
        )
    ''')
    c.execute('''
        CREATE TABLE IF NOT EXISTS prices (
            sku TEXT PRIMARY KEY,
            price REAL
        )
    ''')
    conn.commit()
    conn.close()

init_db()

# -------------------------- Retry decorator ------------------------------

def retry(max_retries=3, backoff=2):
    def deco(func):
        @wraps(func)
        def wrapper(*args, **kwargs):
            attempt = 0
            while True:
                try:
                    return func(*args, **kwargs)
                except Exception as e:
                    attempt += 1
                    logger.warning('Attempt %s failed for %s: %s', attempt, func.__name__, e)
                    if attempt >= max_retries:
                        logger.exception('Max retries reached for %s', func.__name__)
                        raise
                    time.sleep(backoff * attempt)
        return wrapper
    return deco

# -------------------------- AliExpress API (skeleton) --------------------

class AliExpressAPI:
    def __init__(self, cfg):
        self.key = cfg.get('ali_app_key')
        self.secret = cfg.get('ali_app_secret')
        self.base = 'http://gw.api.taobao.com/router/rest'  # affiliate endpoint used as example

    @retry(max_retries=3, backoff=2)
    def fetch_product(self, ali_id: str):
        """Fetch product data. This is a placeholder-simulated response; replace with real parsing."""
        logger.info('Fetching AliExpress product %s', ali_id)
        # Simulated response structure similar to Ali affiliate SDK
        simulated = {
            'aliexpress_affiliate_productdetail_get_response': {
                'resp_result': {
                    'result': {
                        'products': [
                            {
                                'product_id': ali_id,
                                'subject': 'Sample Product ' + str(ali_id),
                                'description': 'Auto-generated sample description',
                                'target_sale_price': '9.99',
                                'total_avaliable_stock': '120',
                                'image_urls': 'https://via.placeholder.com/600;https://via.placeholder.com/800',
                                'first_level_category_name': 'Phones & Telecommunications',
                                'brand_name': 'DemoBrand',
                                'sku_infos': [
                                    {'sku_id': '1', 'color': 'Black', 'size': 'M'},
                                    {'sku_id': '2', 'color': 'White', 'size': 'L'},
                                ],
                                'specs_module': {'Weight': '200g', 'Dimensions': '10x5x2 cm'},
                                'upc': None,
                                'ean': None,
                                'mpn': None
                            }
                        ]
                    }
                }
            }
        }
        return simulated

# -------------------------- eBay API (skeleton) --------------------------

class EbayAPI:
    def __init__(self, cfg):
        self.client_id = cfg.get('ebay_client_id')
        self.client_secret = cfg.get('ebay_client_secret')
        self.token = cfg.get('ebay_token')
        self.use_sandbox = cfg.get('use_sandbox', True)
        self.marketplace = cfg.get('marketplace_id', 'EBAY-AU')
        self.base = 'https://api.sandbox.ebay.com' if self.use_sandbox else 'https://api.ebay.com'

    def set_token(self, token):
        self.token = token

    @retry(max_retries=3, backoff=2)
    def create_inventory_item(self, sku: str, payload: dict):
        # Placeholder: in production call Inventory API
        logger.info('Simulated create inventory item %s', sku)
        return {'sku': sku}

    @retry(max_retries=3, backoff=2)
    def create_offer(self, payload: dict):
        logger.info('Simulated create offer')
        return {'offerId': 'SIM-OFFER-' + str(int(time.time()))}

    @retry(max_retries=3, backoff=2)
    def publish_offer(self, offer_id: str):
        logger.info('Simulated publish offer %s', offer_id)
        return {'status': 'PUBLISHED', 'offerId': offer_id}

    @retry(max_retries=3, backoff=2)
    def update_inventory_quantity(self, sku: str, qty: int):
        logger.info('Simulated update qty for %s -> %s', sku, qty)
        return True

    @retry(max_retries=3, backoff=2)
    def get_orders(self):
        logger.info('Simulated get orders')
        return []

# -------------------------- Business logic --------------------------------

def map_category(ali_category: str):
    if not ali_category:
        return None
    return ALI_TO_EBAY.get(ali_category)

class DropshipWorker:
    def __init__(self, cfg):
        self.cfg = cfg
        self.ali = AliExpressAPI(cfg)
        self.ebay = EbayAPI(cfg)
        self._stop_event = threading.Event()
        self.sync_interval = int(cfg.get('sync_interval_hours', 6)) * 3600

    def import_single(self, ali_id: str, markup_percent: float = None):
        product = self.ali.fetch_product(ali_id)
        # convert to normalized product dict
        prod = self._normalize_ali_product(product)
        if markup_percent is None:
            markup_percent = self.cfg.get('markup_percent', 30.0)
        ebay_item_id = self._create_ebay_listing(prod, markup_percent)
        return ebay_item_id

    def _normalize_ali_product(self, raw):
        # Safely parse simulated response
        try:
            p = raw['aliexpress_affiliate_productdetail_get_response']['resp_result']['result']['products'][0]
        except Exception:
            raise ValueError('Unexpected AliExpress response')
        prod = {
            'id': p.get('product_id'),
            'title': p.get('subject'),
            'description': p.get('description'),
            'price': float(p.get('target_sale_price') or 0),
            'qty': int(p.get('total_avaliable_stock') or 0),
            'images': p.get('image_urls', '').split(';') if p.get('image_urls') else [],
            'variants': p.get('sku_infos', []),
            'category': p.get('first_level_category_name')
        }
        return prod

    def _create_ebay_listing(self, product: dict, markup_percent: float):
        # Build inventory payload
        title = (product.get('title') or '')[:80]
        price = round(product.get('price', 0) * (1 + markup_percent / 100.0), 2)
        qty = min(product.get('qty', 0), 999)
        sku = f"ALI-{product.get('id')}"

        # Advanced mapping (aspects, identifiers) - light touch here
        aspects = {}
        identifiers = {}

        payload_inventory = {
            'sku': sku,
            'product': {
                'title': title,
                'description': product.get('description'),
                'imageUrls': product.get('images'),
                'aspects': aspects,
            },
            'availability': {'shipToLocationAvailability': {'quantity': qty}}
        }
        # Create inventory item (simulated)
        inv = self.ebay.create_inventory_item(sku, payload_inventory)

        # Create offer payload
        offer_payload = {
            'sku': sku,
            'marketplaceId': self.ebay.marketplace,
            'format': 'FIXED_PRICE',
            'availableQuantity': qty,
            'pricingSummary': {'price': {'value': str(price), 'currency': 'USD'}}
        }
        offer = self.ebay.create_offer(offer_payload)
        offer_id = offer.get('offerId')
        pub = self.ebay.publish_offer(offer_id)

        # Save to DB
        conn = sqlite3.connect(DB_FILE)
        c = conn.cursor()
        c.execute('INSERT OR REPLACE INTO products (ali_product_id, title, ebay_item_id, price, qty, last_sync, raw) VALUES (?, ?, ?, ?, ?, ?, ?)',
                  (product.get('id'), title, offer_id, price, qty, datetime.utcnow().isoformat(), json.dumps(product)))
        conn.commit()
        conn.close()
        logger.info('Created eBay listing %s for Ali %s', offer_id, product.get('id'))
        return offer_id

    def import_bulk_csv(self, csv_path: str):
        results = []
        with open(csv_path, newline='', encoding='utf-8') as fh:
            reader = csv.DictReader(fh)
            for row in reader:
                ali_id = row.get('ali_id') or row.get('product_id')
                if not ali_id:
                    continue
                try:
                    res = self.import_single(ali_id)
                    results.append((ali_id, res, 'ok'))
                except Exception as e:
                    logger.exception('Bulk import failed for %s', ali_id)
                    results.append((ali_id, None, str(e)))
        return results

    def sync_stocks_now(self):
        conn = sqlite3.connect(DB_FILE)
        c = conn.cursor()
        c.execute('SELECT ali_product_id, raw, ebay_item_id FROM products')
        rows = c.fetchall()
        conn.close()
        for ali_id, raw, ebay_item_id in rows:
            try:
                prod = json.loads(raw)
                fresh = self.ali.fetch_product(ali_id)
                fresh_norm = self._normalize_ali_product(fresh)
                new_qty = fresh_norm.get('qty', 0)
                if new_qty != prod.get('qty'):
                    ok = self.ebay.update_inventory_quantity(f'ALI-{ali_id}', new_qty)
                    if ok:
                        logger.info('Stock updated for %s -> %s', ali_id, new_qty)
                        conn = sqlite3.connect(DB_FILE)
                        c = conn.cursor()
                        c.execute('UPDATE products SET qty=?, last_sync=?, raw=? WHERE ali_product_id=?',
                                  (new_qty, datetime.utcnow().isoformat(), json.dumps(fresh_norm), ali_id))
                        conn.commit()
                        conn.close()
            except Exception as e:
                logger.exception('Failed sync for %s: %s', ali_id, e)

    def start_auto_sync(self):
        logger.info('Starting auto-sync every %s seconds', self.sync_interval)
        self._stop_event.clear()
        threading.Thread(target=self._auto_sync_loop, daemon=True).start()

    def stop_auto_sync(self):
        logger.info('Stopping auto-sync')
        self._stop_event.set()

    def _auto_sync_loop(self):
        while not self._stop_event.is_set():
            try:
                self.sync_stocks_now()
            except Exception:
                logger.exception('Auto-sync iteration failed')
            self._stop_event.wait(self.sync_interval)

# -------------------------- Analytics ------------------------------------

class Analytics:
    def __init__(self):
        pass

    def dashboard_summary(self):
        conn = sqlite3.connect(DB_FILE)
        c = conn.cursor()
        c.execute('SELECT COUNT(*), SUM(price), SUM(qty) FROM products')
        row = c.fetchone()
        conn.close()
        return {'count': row[0] or 0, 'total_value': row[1] or 0.0, 'total_qty': row[2] or 0}

# -------------------------- Image helpers --------------------------------

def watermark_image_unique(image_url, sku):
    try:
        response = requests.get(image_url, timeout=10)
        response.raise_for_status()
        img = Image.open(BytesIO(response.content)).convert('RGB')
        draw = ImageDraw.Draw(img)
        font = ImageFont.load_default()
        draw.text((10, 10), '© Circle Group', fill='white', font=font)
        out = f'watermarked_{sku}_{int(time.time())}.jpg'
        img.save(out)
        logger.info('Saved watermark %s', out)
        return out
    except Exception as e:
        logger.warning('Watermark failed: %s', e)
        return image_url

# -------------------------- GUI (Tkinter) --------------------------------

class AppGUI(tk.Tk):
    def __init__(self, cfg):
        super().__init__()
        self.cfg = cfg
        self.worker = DropshipWorker(cfg)
        self.analytics = Analytics()
        self.title('Dropship Automator - Clean Full')
        self.geometry('900x650')
        self._build()
        self._poll_logs()

    def _build(self):
        notebook = ttk.Notebook(self)
        notebook.pack(fill='both', expand=True)

        # Config
        conf = ttk.Frame(notebook)
        notebook.add(conf, text='Config')
        ttk.Label(conf, text='eBay Token:').grid(column=0, row=0, sticky='w', padx=8, pady=8)
        self.ebay_token_var = tk.StringVar(value=self.cfg.get('ebay_token', ''))
        ttk.Entry(conf, textvariable=self.ebay_token_var, width=60).grid(column=1, row=0, sticky='w')
        ttk.Label(conf, text='Markup %:').grid(column=0, row=1, sticky='w', padx=8, pady=8)
        self.markup_var = tk.DoubleVar(value=self.cfg.get('markup_percent', 30.0))
        ttk.Entry(conf, textvariable=self.markup_var, width=8).grid(column=1, row=1, sticky='w')
        ttk.Button(conf, text='Save Config', command=self.save_cfg).grid(column=1, row=2, sticky='w', pady=10)

        # Import
        imp = ttk.Frame(notebook)
        notebook.add(imp, text='Import')
        ttk.Label(imp, text='AliExpress ID/URL:').grid(column=0, row=0, sticky='w', padx=8, pady=8)
        self.ali_entry = ttk.Entry(imp, width=50)
        self.ali_entry.grid(column=1, row=0, sticky='w')
        ttk.Label(imp, text='Custom Title (opt):').grid(column=0, row=1, sticky='w', padx=8, pady=8)
        self.title_entry = ttk.Entry(imp, width=50)
        self.title_entry.grid(column=1, row=1, sticky='w')
        ttk.Button(imp, text='Import Single', command=self.import_single).grid(column=1, row=2, sticky='w', pady=8)
        ttk.Button(imp, text='Import CSV', command=self.import_csv).grid(column=1, row=2, sticky='e', pady=8)

        # Sync
        sync = ttk.Frame(notebook)
        notebook.add(sync, text='Sync')
        ttk.Button(sync, text='Sync Now', command=self.sync_now).grid(column=0, row=0, padx=8, pady=8)
        self.auto_sync_btn = ttk.Button(sync, text='Start Auto-Sync', command=self.toggle_auto_sync)
        self.auto_sync_btn.grid(column=1, row=0, padx=8, pady=8)

        ttk.Label(sync, text='Synced products (DB):').grid(column=0, row=1, sticky='w', padx=8, pady=8)
        self.synced_list = tk.Listbox(sync, height=8)
        self.synced_list.grid(column=0, row=2, columnspan=3, sticky='we', padx=8)
        self._refresh_synced_list()

        # Analytics
        analytics = ttk.Frame(notebook)
        notebook.add(analytics, text='Analytics')
        ttk.Button(analytics, text='Show Charts', command=self.plot_btn).pack(pady=8)
        self.stats_label = ttk.Label(analytics, text='Summary:')
        self.stats_label.pack()
        ttk.Button(analytics, text='Refresh Stats', command=self.refresh_stats).pack(pady=8)

        # Logs
        logs = ttk.Frame(notebook)
        notebook.add(logs, text='Logs')
        self.logbox = scrolledtext.ScrolledText(logs, height=20)
        self.logbox.pack(fill='both', expand=True, padx=8, pady=8)
        frame = ttk.Frame(logs)
        frame.pack(fill='x', padx=8)
        self.search_entry = ttk.Entry(frame, width=40)
        self.search_entry.pack(side='left')
        ttk.Button(frame, text='Search Logs', command=self.search_logs).pack(side='left', padx=6)

    # GUI actions
    def save_cfg(self):
        self.cfg['ebay_token'] = self.ebay_token_var.get().strip()
        self.cfg['markup_percent'] = float(self.markup_var.get())
        save_config(self.cfg)
        messagebox.showinfo('Saved', 'Configuration saved (encrypted).')

    def import_single(self):
        ali = self.ali_entry.get().strip()
        if not ali:
            messagebox.showwarning('Empty', 'Enter AliExpress ID or URL')
            return
        cfg = load_config()
        t = threading.Thread(target=self._import_single_bg, args=(ali, cfg), daemon=True)
        t.start()

    def _import_single_bg(self, ali, cfg):
        try:
            worker = DropshipWorker(cfg)
            offer_id = worker.import_single(extract_id(ali), markup_percent=self.cfg.get('markup_percent'))
            self._log_ui(f'Imported {ali} -> {offer_id}')
        except Exception as e:
            self._log_ui(f'Import error: {e}')

    def import_csv(self):
        cfg = load_config()
        file = filedialog.askopenfilename(filetypes=[('CSV','*.csv')])
        if not file:
            return
        t = threading.Thread(target=self._import_csv_bg, args=(file, cfg), daemon=True)
        t.start()

    def _import_csv_bg(self, file, cfg):
        worker = DropshipWorker(cfg)
        results = worker.import_bulk_csv(file)
        self._log_ui(f'CSV import results: {len(results)} rows')

    def sync_now(self):
        cfg = load_config()
        t = threading.Thread(target=self._sync_now_bg, args=(cfg,), daemon=True)
        t.start()

    def _sync_now_bg(self, cfg):
        worker = DropshipWorker(cfg)
        worker.sync_stocks_now()
        self._log_ui('Stock sync completed')

    def toggle_auto_sync(self):
        cfg = load_config()
        if self.auto_sync_btn['text'].startswith('Start'):
            worker = DropshipWorker(cfg)
            worker.start_auto_sync()
            self.auto_sync_btn['text'] = 'Stop Auto-Sync'
            self._log_ui('Auto-sync started')
        else:
            # Stopping isn't wired to the single worker instance here; user can restart app to stop
            self.auto_sync_btn['text'] = 'Start Auto-Sync'
            self._log_ui('Auto-sync stopped (restart to fully stop)')

    def plot_btn(self):
        try:
            data = {'sales': [1, 3, 2, 5, 6, 4]}
            plt.figure(figsize=(6,3))
            plt.plot(data['sales'])
            plt.title('Sales sample')
            plt.show()
            self._log_ui('Displayed analytics chart')
        except Exception as e:
            self._log_ui(f'Plot error: {e}')

    def refresh_stats(self):
        s = self.analytics.dashboard_summary()
        self.stats_label['text'] = f"Summary: products={s['count']} value={s['total_value']} qty={s['total_qty']}"

    def _refresh_synced_list(self):
        conn = sqlite3.connect(DB_FILE)
        c = conn.cursor()
        c.execute('SELECT product_id FROM products')
        rows = c.fetchall()
        conn.close()
        self.synced_list.delete(0, tk.END)
        for r in rows:
            self.synced_list.insert(tk.END, r[0])

    def search_logs(self):
        q = self.search_entry.get().strip().lower()
        self.logbox.delete('1.0', tk.END)
        if os.path.exists(LOG_FILE):
            with open(LOG_FILE, 'r', encoding='utf-8', errors='ignore') as f:
                for ln in f:
                    if q in ln.lower():
                        self.logbox.insert(tk.END, ln)
        self._log_ui(f'Search logs for: {q}')

    def _log_ui(self, msg):
        timestamp = datetime.utcnow().isoformat()
        try:
            self.logbox.insert(tk.END, f'[{timestamp}] {msg}\n')
            self.logbox.see(tk.END)
        except Exception:
            pass
        logger.info(msg)

    def _poll_logs(self):
        # periodically refresh from file tail
        try:
            if os.path.exists(LOG_FILE):
                with open(LOG_FILE, 'r', encoding='utf-8', errors='ignore') as f:
                    data = f.read()[-8000:]
                self.logbox.delete('1.0', tk.END)
                self.logbox.insert(tk.END, data)
        except Exception:
            pass
        self.after(3000, self._poll_logs)

# -------------------------- Small helpers --------------------------------

def extract_id(s: str) -> str:
    # accept plain numeric id or full Ali URL
    try:
        m = re.search(r'/item/(\d+)\.html', s)
        if m:
            return m.group(1)
        if s.isdigit():
            return s
    except Exception:
        pass
    raise ValueError('Invalid AliExpress ID or URL')

# -------------------------- CLI Simulation -------------------------------

def run_simulation(cfg):
    worker = DropshipWorker(cfg)
    print('Import single simulation ->', worker.import_single('12345'))
    print('Bulk simulate ->', worker.import_bulk_csv(os.path.join(APP_DIR, 'test_bulk.csv')))

# -------------------------- Main ----------------------------------------

if __name__ == '__main__':
    cfg = load_config()
    app = AppGUI(cfg)
    app.mainloop()
